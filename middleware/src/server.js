// Generated by CoffeeScript 1.7.1
(function() {
  var child_process, exec, fs, languages, randomstring, readline, server, spawn, temp, ws, _;

  ws = require('ws');

  _ = require('underscore');

  fs = require('fs');

  temp = require('temp');

  readline = require('readline');

  randomstring = require('randomstring');

  child_process = require('child_process');

  exec = child_process.exec;

  spawn = child_process.spawn;

  server = new ws.Server({
    port: 8080
  });

  console.log("Server running.");

  languages = {
    'python': function(maze_file, code_file, prefix_string) {
      return spawn("python", ["../../backend/python/MazeLogic.py", maze_file, code_file, prefix_string]);
    }
  };

  server.on('connection', function(ws) {
    var code_language, code_recv, load_logic, logic, logic_out, maze_data, maze_recv, prefix_regex, prefix_string, reset, start;
    console.log("Connection received.");
    ws.send("CONNECTED");
    maze_data = [];
    maze_recv = false;
    code_recv = false;
    logic = void 0;
    logic_out = void 0;
    start = true;
    reset = false;
    code_language = void 0;
    prefix_string = randomstring.generate(20);
    prefix_regex = RegExp("^\\[" + prefix_string + "\\]");
    load_logic = function(dir_path) {
      var logic_err;
      logic = languages['python']("" + dir_path + "/maze.json", "" + dir_path + "/code.py", prefix_string);
      logic.stdout.setEncoding('utf8');
      logic.stderr.setEncoding('utf8');
      logic_out = readline.createInterface({
        input: logic.stdout,
        terminal: false
      });
      logic_err = readline.createInterface({
        input: logic.stderr,
        terminal: false
      });
      logic_out.on('line', function(line) {
        if (prefix_regex.test(line)) {
          line = line.slice(22);
          if (!/^\[RANDOM\]/.test(line)) {
            if (reset) {
              if (/^\[RESET\].*/.test(line)) {
                line = line.slice(7);
                ws.send(line);
                return reset = false;
              }
            } else {
              return maze_data = maze_data.concat(line);
            }
          }
        } else {
          return ws.send("[CONSOLE]" + line);
        }
      });
      logic_err.on('line', function(line) {
        return ws.send("[CONSOLE]" + line);
      });
      logic.on('close', function(code) {
        logic = void 0;
        logic_err = void 0;
        return logic_out = void 0;
      });
      logic.on('err', function(err) {
        return console.log(err);
      });
      return ws.send("READY");
    };
    ws.on('error', function(err) {
      return console.log(err);
    });
    return temp.mkdir('connection', function(err, dir_path) {
      console.log("directory: " + dir_path);
      return ws.on('message', function(message) {
        var match, reg_ex;
        console.log(message);
        if (/^\[MAZE\].*/.test(message)) {
          console.log('message');
          message = message.slice(6);
          return fs.writeFile("" + dir_path + "/maze.json", message, function(err) {
            if (err) {
              console.log(err);
            } else {
              maze_recv = true;
            }
            if (code_recv && maze_recv) {
              code_recv = false;
              maze_recv = false;
              return load_logic(dir_path);
            }
          });
        } else if (/^\[CODE\].*/.test(message)) {
          console.log('');
          message = message.slice(6);
          reg_ex = /(\[.*\])/;
          match = reg_ex.exec(message);
          code_language = match[0];
          message = message.slice(code_language.length + 2);
          console.log(message);
          console.log(code_language);
          return fs.writeFile("" + dir_path + "/code.py", message, function(err) {
            if (err) {
              console.log(err);
            } else {
              code_recv = true;
            }
            if (code_recv && maze_recv) {
              code_recv = false;
              maze_recv = false;
              return load_logic(dir_path);
            }
          });
        } else if (message === "STEP") {
          if (maze_data.length > 0) {
            start = false;
            if (logic) {
              logic.stdin.write("step\n");
            }
            ws.send(maze_data[0]);
            return maze_data = maze_data.slice(1);
          } else {
            console.log(logic);
            if (logic) {
              logic.stdin.write("step\n");
            }
            return ws.send("NO_DATA");
          }
        } else if (message === "RESET") {
          maze_data = [];
          reset = true;
          if (logic) {
            return logic.stdin.write("reset\n");
          }
        }
      });
    });
  });

}).call(this);
